# Turn MyBee instance into GitHub self-hosted runner

Статья посвящена разворачиванию эфемерных *self-hosted* [GitHub runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners) на базе виртуальных машин [bhyve](https://en.wikipedia.org/wiki/Bhyve) под управлением [MyBee OS](https://myb.convectix.com) с функцией авто-скейлинга. 
Особая ценность решения, актуальная для 'IT-меньшинств' - возможность (помимо большого выбора *Linux* дистрибутивов и *Windows OS*) использовать экзотические дистрибутивы ОС, которые официально не поддерживаются GitHub: [Android-x64](https://www.android-x86.org/download), [DragonflyBSD](https://dragonflybsd.org), [FreeBSD](https://www.freebsd.org), [NetBSD](https://netbsd.org) и [OpenBSD](https://openbsd.org). 
Учитывая популярность платформы GitHub при разработке открытых и портируемых приложений, это может стать небольшим подарком для тех, кто работает над улучшением *CI/QA* процессов в отношении подобных систем.

<center>
<img src="/images/art-gh_runners/bsd-action.png" width="1024">
</center>

## Введение

[GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions) предоставляют частным репозиториям возможность легко создавать конвейер [CI/CD](https://en.wikipedia.org/wiki/CI/CD), поместив определенный [YAML](https://en.wikipedia.org/wiki/YAML) файл в структуре репозитория. На момент написания статьи (вторая половина 2022), по-умолчанию задания выполняются в среде, 
представляющей из себя запущенную в [Azure](https://azure.microsoft.com) виртуальную машину типа [Standard_DS2_v2](https://docs.microsoft.com/en-us/azure/virtual-machines/dv2-dsv2-series):

|                                   |                                       |
|-----------------------------------| ------------------------------------- |
|vCPU:                              |                  2                    |
|Memory, GiB:                       |                  7                    |
|Temp storage (SSD) GiB:            |                 100                   |
|Max temp storage throughput:       | IOPS/Read MBps/Write MBps: 6000/93/46 |
|Max data disks:                    |                  8                    |
|Throughput, IOPS:                  |                 8x500                 |
|Max NICs:                          |                  2                    |
|Expected network bandwidth (Mbps): |                 1500                  |


## О Github Actions/runners

В Github-hosted runners у вас есть некоторый набор образов для различных операционных систем и версий, имеющие определенный набор библиотек и SDK. 
Рабочие процессы имеют ограничение по времени в 6 часов, после чего задание автоматически отменяется, а Runner очищается. 
Для большинства случаев этого более чем достаточно. Но что, если вы хотите запустить свои тесты в операционной системе, которая в списке поддерживаемых образов отсутствует? 
Или вам требуется больше пространства на диске, больше CPU ядер и оперативной памяти? Или вам необходимо собрать кастомное специализированное окружение, например, с доступом к графическому 
процессору или другому специализированному оборудованию? И разумеется, это решение должно укладываться в адекватную цену. 
В этом случае, Github рекомендует использовать свои собственные runners. Вы можете зарегистрировать и использовать два типа раннеров:

- *Persistent* - каждая job может использовать данный раннер бесконечное число раз - окружение не перезагружается и соответственно, для каждой последующей job в окружении могут оставаться артефакты, оставшиеся от работы предыдущей;
- *Ephemeral* - раннер этого типа принимает только 1 задачу, после которой окружение откатывается к первоначальному состоянию, что гарантирует получение всегда чистого окружения перед следующими тестами. Это определенно является хорошим преимуществом и экономит вам время по обслуживанию окружения. Мы сфокусируемся только на этом типе раннеров и добьемся авто-скейлинга.

Итак, подытожим разницу между *Github-hosted* и *Self-hosted*, чтобы мы лучше понимали решаемые проблемы:

*GitHub-hosted runners:*

- ОС, на которых работают раннеры обновляется автоматически, имеют определяемые командой GitHub первоначальные наборы и версии пакетов и инструментов, на которые вы повлиять не можете;
- Обслуживаются командой GitHub;
- Имеют ограничения в ресурсах, типе оборудования и доступу к физическим ресурсам ( доступ к GPU, USB и прочей периферии отсутствует );
- Заложена функция автоскейла, однако все упирается в ваш тарифный план: в качестве стоимости, потребляются 'free minutes' вашего GitHub плана, это влияет на интенсивность использования runners: например на бесплатном тарифе вы имеете серъезные ограничения в виде количества задач в минуту;

*Self-hosted runners:*

- ОС и компоненты в окружении устанавливаете, настраиваете, обновляете и обслуживаете только вы. Это может быть как большим плюсом (вы фиксируете версии софта и определяете набор ПО, что существенно влияет на скорость bootstrap/прогрева нового раннера), так и минусом - стоимость создания и обслуживания инфраструктуры. Этот минус мы нивелируем использованием *MyBee*, о чем читайте ниже;
- По-умолчанию, отсутствует возможность Auto-scaling, что также будем решать использованием *MyBee*.
- Вы можете использовать облачные сервисы или собственные выделенные сервера, тем самым получая максимальную мощность без какой-либо наценки -  дешевизна;
- Вы можете кастомизировать не только ПО, но и оборудование, обеспечив доступ к необходимой под ваши кейсы периферии;

## О MyBee

*MyBee* - это бесплатный свободный open-source дистрибутив, не требующий знаний и умений при работе с Unix/command line для того, чтобы создать и сразу начать использовать виртуальную машину. Поле установки, пользователю доступен простейший API для получания ВМ самым легким образом, но зайти в командную строку *MyBee* также никто не запрещает. Проектом поддерживается работа и своевременные обновления большого количества дистрибутивов, что можно использовать в качестве высокопроизводительных self-hosted раннеров. На момент написания статьи, [список ОС](images.md) доступных для создания 'из коробки':

```
dflybsd-DragonflyBSD-hammer-x64-6
freebsd-FreeBSD-ufs-x64-12.3
freebsd-FreeBSD-ufs-x64-13.0
freebsd-FreeBSD-ufs-x64-13.1
freebsd-FreeBSD-ufs-x64-14
freebsd-FreeBSD-zfs-x64-12.3
freebsd-FreeBSD-zfs-x64-13.0
freebsd-FreeBSD-zfs-x64-13.1
freebsd-FreeBSD-zfs-x64-14
freebsd-OPNSense-22-RELEASE-amd64-22
linux-Alma-9-x86_64
linux-CentOS-7-x86_64
linux-CentOS-stream-8-x86_64
linux-CentOS-stream-9-x86_64
linux-Debian-x86-10
linux-Debian-x86-11
linux-Debian-x86-9
linux-Fedora-36-x86_64
linux-FreePBX-16-x86_64
linux-HomeAssistant-8
linux-Kali-2022-amd64
linux-Oracle-7-x86_64
linux-Oracle-8-x86_64
linux-Oracle-9-x86_64
linux-Rocky-8-x86_64
linux-Rocky-9-x86_64
linux-kubernetes-24
linux-rabbitmq
linux-ubuntudesktop-amd64-22.04
linux-ubuntuserver-amd64-20.04
linux-ubuntuserver-amd64-22.04
netbsd-netbsd-x86-9
openbsd-openbsd-x86-7
openbsd-openbsd-x86-70
```

Дистрибутив может быть установлен на ваш выделенный сервер любой конфигурации. При инсталляции нескольких нод, может быть организован кластер с единым L2 сегментом ( [https://en.wikipedia.org/wiki/Virtual_Extensible_LAN](vxlan) ), в котором через единую точку (API) входа будут создаваться ВМ на разных нодах, обеспечивая *DRS*  (Dynamic Resource Scheduler). Для тех, у кого нет выделенного сервера (или кто не желает постоянно оплачивать выделенный сервер ввиду редких задач) существует отдельная опция - смотри подкатом.


## О bhyve

Гипервизор второго типа, изначально разрабатанный компанией [https://www.netapp.com/](NetAPP) и пожертвованный проекту *FreeBSD*. В настоящее время получил широкое распространение в FreeBSD, [https://tritondatacenter.com/smartos](SmartOS)-based системах, 
а также на [https://www.apple.com/macos/](MacOS) под именем [https://github.com/machyve/xhyve](xhyve). Отличительной чертой гипервизора является так называемый 'legacy-free' код. Так, многие пользователи отмечали более эффективную работу ВМ в условиях высокого CPU overcommiting по сравнению с широкораспространенными KVM/XEN, 
что также может быть актуально в отношении Runner-ов, когда один хост обслуживает большое количество окружений.


## Проблемы автоскейлинга

Управлять автоскейлингом призваны [https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks](Webhooks). Каждый раз, когда запускается *pipeline* нового задания, GitHub будет отправлять события через *Webhooks*, которые сообщат, что задание поставлено в очередь и требуется новый работник. Если рабочий процесс уже подключен к сети и находится в режиме ожидания, этот рабочий процесс просыпается и берет задание, перейдя в статус Active. Задача обработчика *Webhook* - подготовить и запустить следующую виртуальную машину. Помимо этого, *Webhook* события сигнализируют нам о прохождении flow - начало и завершение pipeline. Также, события используют метки (labels), на которые ориентировано то или иное задание. Требуется какая-то автоматизация, которая будет запускать раннеры, пользуясь метками как критерием для запуска необходимой ОС и набора ПО в них. Таким образом, вы можете определить несколько типов runner-ов, регулировать флаворы ресурсов ВМ (cpu/ram/hdd), в зависимости от необходимых под те или иные pipeline ресурсы, а также маркировать специализированные runner, имеющие доступ к периферии, например с доступом к GPU или USB токенам. Эту задачу и решает расширение GH runner для *MyBee*, которое является прослойкой между *MyBee* и одним из многих менеджеров GH runner, в данном случае мы воспользуемся https://github.com/cloudbase/garm.
 

# Настройка

## Требования

Итак, нам необходим установленный дистрибутив MyBee на любое выделенное оборудование. Кроме этого, разумеется, вам потребуется административный доступ к тому GitHub проекту, к которому вы хотите подключить *MyBee* в качестве self-hosted runner. Посколльку Github будет инициировать Webhook событие (обычный HTTP/Rest запрос), *MyBee* должна быть доступна со стороны GH - самое легкое, это использовать сервер с внешним IP адресом, на который будет ссылаться DNS запись. Если вы еще не назначили доменного имени для MyBee, указывающего на внеший IP адрес - обязательно сделайте это. Также, вероятнее всего, вам может потребоваться выпустить Let's encrypt сертификат для данного имени - консоль MyBee [позволяет это сделать](api_fqdn_certbot.md). Например в данном примере, будет использоваться доменное имя 'garm.convectix.com'.


## Инициализация GARM

Работа с модулем происходит через командую строку *nix, для этого в консоле администратора выберете пункт '6) Shell ( warm cloud image )'

Для первичной инициализации (а также просмотра состояния модуля) служит команда `cbsd garm`. Скрипт достаточно self-documented и в зависимости от состояния, выводит те или иные подсказки в качестве возможных следующих шагов. Если вы хотите просмотреть все возможности скрипта, введите:

```
cbsd garm --help
```

Для сброса всех настроек и отката к пред-инициализационному состоянию, используйте вызов `cbsd garm mode=reset`.

Если модуль *GARM* не был проинициализирован, то работа скрипта начнется с сообщения 'garm: PAT not found!' и инструкцией, с чего требуется начать. 
*PAT* или [Personal Access Token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token), необходим для работы с API и будет использоваться MyBee для регистрации и уничтожения Runner. Сгенерируйте новый *PAT* через 'Settings' -> 'Developers settings' -> 'Personal access tokens' -> 'Generate new token'. 
Дайте имя токену (например 'mybee') и снимите ограничение по 'Expiration', иначе вам придется пересоздавать настройки каждый раз при устаревании токена:


![pat1 screenshot](/images/art-gh_runners/pat1.png)


![pat2 screenshot](/images/art-gh_runners/pat2.png)


![pat3 screenshot](/images/art-gh_runners/pat3.png)


В списке полномочий токена, выберете только те права, которые нам необходимы, а именно:


* public_repo - для доступа к публичным репозиториям;
* repo        - для доступа к частным репозиториям;
* admin:org   - если вы планируете использовать это с организацией, в которую у вас есть доступ;


![pat4 screenshot](/images/art-gh_runners/pat4.png)


В результаты вы получите сгенерированный токен вида: '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' - скопируйте его и вставьте в запрос скрипта 'Please insert you PAT here':

Следующий вопрос, на который необходимо ответить: 'Please enter URL which you will use for the hook'. Ожидается ввод правильного URL с вашей инсталляцией MyBee, доступной из Internet - поскольку с ресурсом будет работать GitHub webhooks. В нашем примере мы используем доменное имя garm.convectix.com, соответственно, URL будет выглядеть так: https://garm.convectix.com

Если вы ввели корректный токен и URL доступен от GitHub сети, то увидете статус пулов и ранеров. Это означает, что можно переходить к следующему уровню настроек - создание пулов для ваших организаций и проектов.

![garm_init screenshot](/images/art-gh_runners/garm_init1.png)

## Подключение GitHub проекта к MyBee GARM

Определитесь, к какому проекту GitHub вы хотите подключить self-hosted раннеры на базе MyBee. В этой статье мы будем подключать репозиторий https://github.com/cbsd/gtest. Как мы видим, имя репозитория - 'gtest', который находится в организации 'cbsd': 'cbsd/gtest'.

Для этого, запускаем скрипт с параметром 'mode=addrepo' и соответствующим названием организации и репозитория:


```
cbsd garm mode=addrepo owner="cbsd" reponame="gtest"
```

Скрипт выдаст очередную инструкцию по интеграции Webhook с MyBee, разберем ее:

1) В GitHub вы должны задать те события, на которые GitHub будет триггерить вашу инсталляцию MyBee. Заходим в Settings вашего репозитория:

![repo1 screenshot](/images/art-gh_runners/repo1.png)

Выберете *Webhooks* в меню слева и нажмите кнопку добавления нового webhook: 'Add webhook' (справа)

![repo2 screenshot](/images/art-gh_runners/repo2.png)

Заполняем поля, где:

Payload URL: - корректный и доступный URL вашего MyBee, например в нашем случае, это: https://garm.convectix.com;
Content type: - измените значение на 'application/json';
Secret: - скрипт GARM вам его должен высветить, вставьте информацию из консоли в это поле. Токен создается автоматически;

Из списка в области 'Which events would you like to trigger this webhook?' нам не нужно дергать MyBee на все события, а требуется всего одно - реагировать на 'Workflow jobs' - именно оно является источником на событие старта новой задачи.
Поэтому выбираем 'Let me select individual events. ' и устанавливаем флажек на событии 'Workflow jobs' внизу списка.

![repo3a screenshot](/images/art-gh_runners/repo3a.png)

![repo3b screenshot](/images/art-gh_runners/repo3b.png)

При нажатии 'Add webhook', мы добавляем и активируем отправку событий со стороны GitHub на MyBee. В консоле нажимаем 'Enter' по готовности и если связь между MyBee и GitHub установлена корректно, репозиторий начнет обслуживаться.

![repo4 screenshot](/images/art-gh_runners/repo4.png)

## Создание пула

Следующая и последняя сущность на пути к решению скейлинга и раннеров по-требованию - это создание именованной группы runner-ов - пула. Вы можете создавать неограниченное количество пулов. Пул характеризуется следующими свойствами:

- Дистрибутив ОС ( image ), который будет обслуживать job-ы для данного пула. Все runner-ы этого пула будут использовать только один дистрибутив - если вы хотите, чтобы pipeline отрабатывал на ряде дистрибутивов или ОС - вам нужно создать столько пулов, сколько дистрибутивов вы хотите использовать;
- Flavors. Физические характеристики виртуальных машин: vCPU, RAM, DSK. Создавать кастомные flavors вы можете через диалог `cbsd vmpackages-tui` ) в Unix shell, по-умолчанию идут 3 flavors: 'small1' (1/2g/20g), 'medium1' (4/8g/60g) и 'large1' (8/16g/100g);
- Labels: метки являются маркерами (или фильтром) для выбора тех или иных Runner. Это может быть произвольный критерий в виде слова или слов через запятую, если меток несколько. Например, метками вы можете маркировать архитектуру ( x86-64, armv8 и тд) или дистрибутив ( openbsd ) или различные возможности и способности этой группы раннеров (gpu-passthru, usb-token, highperf) и тд;
- Минимальное количество раннеров в режиме 'idle'. То число окружений, который *MyBee GARM* будет стараться всегда подготовить. Поскольку создание и запуск нового runner может занимать некоторое время, желательно предварительно иметь 'прогретыми' некоторое количество раннеров, которые могут незамедлительно обработать новую задачу. Разумеется, если число запусков pipeline высокое и цена вопроса ресурсов на втором плане - имеет смысл ставить высокое значение. Если же число запусков pipeline редкое, этот параметр позволяет вам существенно сэкономить на ресурсах. Так, если вы установите этот параметр в нулевое значение, runner будет создаваться только по факту запуска job. В этом в случае, при использовании облачного MyBee, вы оплатите только время работы виртуальной машины на момент работы pipeline. Если в репозитории лишь несколько изменений в сутках или реже - это существенная экономия средств и ресурсов.
- Максимальное количество раннеров. Предыдущий параметр 'Idle' регулирует число свободных runner, однако если нагрузка на репозиторий высокая, *MyBee GARM* будет стремиться создать то количество Runner, сколько необходимо для обработки всех задач - другими словами, это и есть необходимый нам Auto-scaling механизм. Однако он чреват шансом исчерпать все доступные ресурсы (например, в репозиторий стали делать несколько сотен изменений в минуту). Вы можете защититься, установив верхнюю границу максимального числа Runner. В этом случае, по достижению установленного лимита, новые задачи буду ждать освобождения ресурсов от предыдущих раннеров.

Например, создадим пул из OpenBSD окружений:

```
cbsd garm mode=addpool
```

На первом шаге выбираем flavor для ВМ данного пула:

```
Available flavors, please select name for new pool:
NAME     CPU  RAM  DISK
small1   1    1g   10g
medium1  4    4g   20g
```

Например: 'small1'.

Следующий шаг - выбор одного из доступных образов:

```
Available images, please select name for new pool:
You choice [alma9 centos7 centos8 debian10 debian11 dflybsd6 freebsd13_ufs freebsd13_zfs freebsd14_ufs freebsd14_zfs netbsd9 openbsd7 opnsense21 oracle7 oracle8 oracle9 rocky8 rocky9 ubuntu20]:
```

Например: openbsd7

Далее выбираем к какому репозиторию будет прикреплен пул. Если вы добавили несколько репозиториев, вам будет предложен список для выбора, разделенные пробелом. Вам необходимо написать необходимый ресурс через ввод 'owner/repo'. Если только один репозиторий - можно просто нажать 'Enter' для подтверждения.


```
Available repositories, please select for new pool:
You choice [cbsd/gtest]: 
SELECTED: cbsd/gtest
```

Следующие шаги - ожидаются integer значения для максимального количества runner (>0) и количество runner в статусе idle (0 или значение, меньше чем max runners):

```
Enter max runners (num): 5
SELECTED: 5
Enter min idle runners (num): 3
SELECTED: 3
```

и наконец, последний шаг - перечисление 'слов-меток' через запятую. Если вам нечего придумать - можете оставить пустым и нажать 'Enter' - runner-ы все равно получат некоторый набор меток (например 'self-hosted', 'mybee' и тип ОС ( linux,freebsd,openbsd,dragonflybsd,netbsd,windows )

```
Enter comma-separated labels: bsd,small
SELECTED: bsd,small

1. Flavors: small2
2. Images: openbsd7
3. Repos: cbsd/gtest
4. Max runners: 5
5. Min idle runners" 3
6. Labels: bsd,small

Select 1-6 to change settings or 'Enter' to apply settings.
```

![pool1 screenshot](/images/art-gh_runners/pool1.png)

После подтверждения вводом 'Enter' начнется процесс создания runner (при min idle > 0 ). Посмотреть состояние можно через `cbsd garm`. Через некоторое время, требуемое количество раннеров появится на странице Runners: Settings -> Actions -> Runners.


![pool2 screenshot](/images/art-gh_runners/pool2.png)

Поздравляем! раннеры заступили на свое боевое дежурство.

## Рабочий процесс/Workflow

Для использования self-hosted раннеров, используйте обычный синтакстис Github actions. Имейте ввиду, что оригинальный git checkout не работает на BSD системах, поэтому вы можете захотеть в качестве 'checkout' шага использовать https://github.com/myci-actions/checkout, 
продублированный в репозиторий нашего проекта convectix:

```
- name: checkout sources
      uses: convectix/checkout@master
```

В качестве примера Github Actions, можете посмотреть на https://github.com/cbsd/gtest/blob/main/.github/workflows/act.yml

Для удаления пула и/или отключения GitHub репозитория от MyBee, используйте `mode=delpool` и `mode=delrepo` соответственно.

## Известные проблемы, баги, дальнейшие планы

*GARM*, как и одноименный модуль к *MyBee* - достаточно молодой проект и первое его включение в MyBee произошло с версии 13.1.1 (mid 2022). 
Поэтому обратная связь особенно важны. Из протестированных гостей в качестве runner (те, должны работать на 100%):

- все BSD;
- Linux: Debian, Ubuntu, CentOS

Примечание1: некоторые системы (особенно NetBSD и DragonflyBSD) могут подготавливаться дольше остальных - в основном, это связано с отсутствием у данных проектов Geo-based зеркал, используемых при установке ПО ( pkg, pkg_add ), поскольку запуск каждого runner - это установка некоторого дополнительного ПО (в основном, доустановка пакетов 'git', 'curl', 'wget' и непосредственно github runner). В продуктовой среде подобный алгоритм не приветствуется, поскольку запуск каждого раннера сопровождается соответствующим трафиком из интернера. Вместо этого, генерируйте свой собственный GOLD-образ для runner - одна из сильных сторон MyBee - предоставление инструментария для генерации собственных cloud-образов. Либо используйте локальные зеркала. В этом случае, новые раннеры будут запускаться в течении 30 секунд.

Примечание2: Использование Windows ОС в качестве runner также возможно, но ввиду известных лицензионных ограничений, данный образ не поставляется с базовой версией MyBee. Вы можете отправить запрос по email для получения Windows образа и лицензий: book-myb at convectix.com

Примечание3: В случае с FreeBSD, в качестве runner вы можете использовать не только виртуальные машины bhyve, но и легковесные контейнера на базе [jail(8)](https://man.freebsd.org/jail/8).

Если что-то пошло не так:

- попробуйте перезагрузить сервис из CLI: `service garm stop` + `service garm start`
- смотрите логи в /var/log/garm/ и файлы up-\*.log в каталоге /tmp

Дальнейшая работа: поддержка GitLab, поддержка Jenkins.

## Эпилог

Резюмируя все выше сказанное, self-hosted runners может быть выгоден:

- тем, у кого 'хайлоад' на ранеры - вы можете регулировать число предварительно 'прогретых' раннеров;
- тем, у кого почти нет запусков в течении суток и кто хочет сэкономить на постоянно запущеном или выделенном сервере: арендуйте runner-ы в облаке по требованию и оплачивайте только время его работы;
- тем, кто хочет использовать кастомные ресурсы, уникальные flavor-ы, не зависеть от ограничений по кол-ву запусков и cputime в облаке GitHub, иметь большие мощности по себестоимости;

*MyBee* позволяет реализовать все это, затратив ~10 минут на настройку. В свою очередь, это оказалось возможным благодаря поддержке cloud образов проекта CBSD, который используется MyBee в качестве примера переиспользования наработок CBSD для легкого создания чего-то комплексного. Проект развивается на некоммерческой основе и добровольные пожертвования очень важны: https://www.patreon.com/clonos


## Попробуйте

У вас нет выделенного сервера, но хотите попробовать? Вы можете использовать облако или аренду MyBee от ConvectIX за себестоимость без наценки (вы платите цену выбранного вами поставщика dedicated сервера - цена образовывается выбранным вами провайдером). Для подробностей, вы можете отправить запрос по email: book-myb at convectix.com

## Demo on youtube:

[![Speedrun from scratch: How to setup GH self-hosted runner demo](/images/act.png)](https://youtu.be/6zLAnkg6dng "Speedrun from scratch: How to setup GH self-hosted runner demo")
